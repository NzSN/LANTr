#include <gtest/gtest.h>
#include <rapidcheck/gtest.h>

#include "base/tree_concepts.hpp"
#include "parser/ast/abst_parsetree.hpp"
#include "parser/languages/language_definitions.hpp"
#include "parser/languages/language_impl.hpp"

namespace L = ::LANTr::Parser::LANGUAGE;

namespace LANTr::Parser::AST {

using ParserImpl   = L::ParserImpl;
using LANGUAGES    = L::LANGUAGE;
using ParserResult = L::ParseResult<LANGUAGES::ARITH>;

struct AstTest: public ::testing::Test {

bool equivalent(L::TreeType<L::ANTLR4>::type* ltree,
                const AbstTree<L::TreeType_t<L::ANTLR4>>* rtree) {
  if (rtree->GetInternal() != ltree ||
      rtree->size() != ltree->children.size()) {
    return false;
  }

  auto iter = ltree->children.cbegin();
  for (auto const& c: rtree->GetChildren()) {
    ASSERTM("out of range", iter < ltree->children.cend());

    const Antlr4Tree* internalTree = c->GetInternal();
    if (internalTree != *iter) {
      return false;
    }

    if (!equivalent(*iter, c.get())) {
      return false;
    }

    ++iter;
  }

  return true;
}

};

RC_GTEST_FIXTURE_PROP(AstTest, Construction, ()) {
  LANTr::Base::Types::Source source =
    "1+2+3+(2*2)";

  ParserImpl parser;
  ParserResult result = parser.Parse<LANGUAGES::ARITH>(source);

  using Tree = L::TreeType_t<L::ImplOfLang_v<LANGUAGES::ARITH>>;
  std::unique_ptr<AbstTree<Tree>> tree = AbstTree<Tree>::BuildFrom(result.tree);

  // Assert that the generated AbstTree is equivalent the tree
  // generated by ParserImpl.
  RC_ASSERT(equivalent(result.tree, tree.get()) &&
            tree->IsLayerEquivalent());
}

} // LANTr::Parser::AST
